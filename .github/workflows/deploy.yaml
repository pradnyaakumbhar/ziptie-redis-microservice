name: Build and Push Microservice to ECR

on:
  workflow_dispatch:

jobs:
  build_and_push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image
        run: |
          IMAGE_URI=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/ziptie-microservice
          docker build -t ziptie-microservice .
          docker tag ziptie-microservice:latest $IMAGE_URI:latest
          docker tag ziptie-microservice:latest $IMAGE_URI:${{ github.sha }}
          docker push $IMAGE_URI:latest
          docker push $IMAGE_URI:${{ github.sha }}

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_push
    if: github.event_name == 'workflow_dispatch'
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      EC2_HOST: ${{ secrets.EC2_HOST }}
      EC2_USER: ${{ secrets.EC2_USER }}
    steps:
      - name: Prepare SSH key
        env:
          SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          install -m 700 -d ~/.ssh
          if echo "$SSH_KEY" | base64 -d >/tmp/id_rsa 2>/dev/null; then
            mv /tmp/id_rsa ~/.ssh/id_rsa
          else
            printf '%s' "$SSH_KEY" > ~/.ssh/id_rsa
          fi
          chmod 600 ~/.ssh/id_rsa
          cat > ~/.ssh/config <<EOF
          Host deploy-target
            HostName $EC2_HOST
            User $EC2_USER
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
          EOF

      - name: Deploy via SSH
        run: |
          ssh deploy-target "AWS_REGION=$AWS_REGION AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID ENV_DIR=/shared bash -s" <<'EOSSH'
          set -euo pipefail

          if ! command -v docker >/dev/null 2>&1; then
            sudo yum update -y
            sudo yum install -y docker
          fi
          sudo systemctl enable --now docker

          if docker compose version >/dev/null 2>&1; then
            COMPOSE_BIN="docker compose"
          elif command -v docker-compose >/dev/null 2>&1; then
            COMPOSE_BIN="docker-compose"
          else
            sudo curl -SL https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            COMPOSE_BIN="docker-compose"
          fi

          sudo mkdir -p /opt/ziptie
          sudo chown "$USER":"$USER" /opt/ziptie

          sudo mkdir -p /opt/ziptie/nginx/certs
          sudo chown "$USER":"$USER" /opt/ziptie/nginx /opt/ziptie/nginx/certs

          if [ ! -f /opt/ziptie/nginx/certs/selfsigned.crt ] || [ ! -f /opt/ziptie/nginx/certs/selfsigned.key ]; then
            openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -keyout /opt/ziptie/nginx/certs/selfsigned.key \
              -out /opt/ziptie/nginx/certs/selfsigned.crt \
              -subj "/CN=44.202.183.197"
          fi

          cat > /opt/ziptie/nginx/default.conf <<'EOF'
          server {
            listen 80;
            server_name _;
            return 301 https://$host$request_uri;
          }

          server {
            listen 443 ssl;
            server_name _;

            ssl_certificate     /etc/nginx/certs/selfsigned.crt;
            ssl_certificate_key /etc/nginx/certs/selfsigned.key;

            location / {
              proxy_pass http://frontend:80;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
            }

            location /api/ {
              proxy_pass http://backend:4000$request_uri;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
            }
          }
          EOF

          cat > /opt/ziptie/docker-compose.yml <<EOF
          version: "3.9"
          services:
            nginx:
              image: nginx:alpine
              depends_on:
                - frontend
                - backend
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - /opt/ziptie/nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
                - /opt/ziptie/nginx/certs:/etc/nginx/certs:ro
            frontend:
              image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/ziptie-frontend:latest
              ports:
                - "8080:80"
              env_file:
                - ${ENV_DIR}/frontend.env
              depends_on:
                - backend
            backend:
              image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/ziptie-backend:latest
              ports:
                - "4000:4000"
              env_file:
                - ${ENV_DIR}/backend.env
            microservice:
              image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/ziptie-microservice:latest
              ports:
                - "3000:3000"
              env_file:
                - ${ENV_DIR}/microservice.env
          EOF

          aws ecr get-login-password --region "${AWS_REGION}" | sudo docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

          cd /opt/ziptie
          sudo ${COMPOSE_BIN} down --remove-orphans || true
          sudo ${COMPOSE_BIN} pull
          sudo ${COMPOSE_BIN} up -d --force-recreate
          EOSSH
